/**
 * ACService.java
 *
 * SCUBA API friendly service for Anonymous Credentials
 * 
 * Copyright (C) Wojciech Mostowski, July 2010. Based on work by Pim Vullers.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package service;

import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.Arrays;

import org.bouncycastle.jce.spec.ECParameterSpec;
import org.bouncycastle.math.ec.ECCurve;
import org.bouncycastle.math.ec.ECFieldElement;
import org.bouncycastle.math.ec.ECFieldElementFp12;
import org.bouncycastle.math.ec.ECFieldElementFp2;
import org.bouncycastle.math.ec.ECPoint;
import org.bouncycastle.math.ec.ECPointFp2;
import org.bouncycastle.math.ec.pairing.ECCurveWithPairing;

import net.sourceforge.scuba.smartcards.APDUListener;
import net.sourceforge.scuba.smartcards.CardService;
import net.sourceforge.scuba.smartcards.CardServiceException;
import net.sourceforge.scuba.smartcards.CommandAPDU;
import net.sourceforge.scuba.smartcards.ResponseAPDU;
import net.sourceforge.scuba.util.Hex;

public class ACService extends CardService {

    private static final long serialVersionUID = 1L;

    private static final byte[] AID = { 0x73, 0x62, 0x63, 0x72, 0x65, 0x64 };

    private static final int[] INITIALISE = { 0x00, 0x01, 0x00, 0x00 };
    private static final int[] PERSONALISE = { 0x00, 0x02, 0x00, 0x00 };
    private static final int[] GET_ATTRIBUTE = { 0x00, 0x03, 0x00, 0x00 };
    private static final int[] GET_KEY = { 0x00, 0x04, 0x00, 0x00 };
    private static final int[] COMPUTE_DH = { 0x00, 0x05, 0x00, 0x00 };
    

    static final public int BLINDED_KEY = 0;
    static final public int SIGNED_NONCE = 1;
    static final public int BLINDED_SIGNATURE = 2;
    static final public int ATTRIBUTE = 3;

    protected CardService service;

    static final int ATTRIBUTE_COUNT = 4;
    /**
     * Control the amount of output generated by this class.
     */
    private static final boolean VERBOSE = true;

    // The length of the keys which is used
    public static final int KEY_LENGTH = 160;

    public class Attribute {
        byte id;
        byte[] value;
    }

    ECCurveWithPairing c;
    ECParameterSpec c_params;
    ECPoint Q;
    Attribute[] a;
    BigInteger[] sa;
    ECPoint[] saQ;
    ECPoint Pc;

    static ECFieldElement ONE;

    public ACService() {
        this((byte[][]) null);
    }

    public ACService(byte[][] attrValues) {
        c = constructCurve(KEY_LENGTH);
        System.out.println("P:" + Hex.toHexString(c.getP().toByteArray()));
        System.out.println("R:" + Hex.toHexString(c.getR().toByteArray()));
        System.out.println("A:" + Hex.toHexString(c.getA().toBigInteger().toByteArray()));
        System.out.println("B:" + Hex.toHexString(c.getB().toBigInteger().toByteArray()));
        System.out.println("Gx:" + Hex.toHexString(c.getG().getX().toBigInteger().toByteArray()));
        System.out.println("Gy:" + Hex.toHexString(c.getG().getY().toBigInteger().toByteArray()));
        
        c_params = new ECParameterSpec(c, c.getG(), c.getR());

        // Construct the fixed point on the curve
        Q = constructFixedPoint(c);

        // Construct a number of attributes
        this.a = constructAttributes(attrValues);

        // Construct the private keys for the attributes
        sa = constructPrivateAttributeKeys(c);

        // Construct the public keys for the attributes from sa and Q
        saQ = constructPublicAttributeKeys(sa, Q);

    }

    public ACService(CardService service) {
        this(service, null);
    }

    public ACService(CardService service, byte[][] attrValues) {
        this(attrValues);
        this.service = service;
    }

    /**
     * Construct a number of attributes
     */
    private Attribute[] constructAttributes(byte[][] attrValues) {
        if (attrValues == null) {
            attrValues = new byte[0][];
        }
        Attribute[] attribute = new Attribute[4];

        for (int i = 0; i < 4; i++) {
            attribute[i] = new Attribute();
            attribute[i].id = (byte) (i + 1);
            attribute[i].value = i < attrValues.length ? attrValues[i]
                    : new byte[] { (byte) i, 0, (byte) i };
        }
        return attribute;
    }

    /**
     * Construct an elliptic curve for the given length (in bits)
     */
    static private ECCurveWithPairing constructCurve(int length) {
        BigInteger u;

        switch (length) {
        case 128:
            u = new BigInteger("1678770247");
            break;
        case 160:
            u = new BigInteger("448873116367");
            break;
        case 192:
            u = new BigInteger("105553250485267");
            break;
        case 224:
            u = new BigInteger("29417389579040251");
            break;
        default:
            u = null;
            break;
        }

        return new ECCurveWithPairing(u);
    }

    /**
     * Construct a fixed point on the given curve
     */
    static private ECPointFp2 constructFixedPoint(ECCurveWithPairing curve) {

        ECFieldElement Qx1, Qx2, Qy1, Qy2;

        switch (curve.getFieldSize()) {
        case 128:
            Qx1 = curve.fromBigInteger(new BigInteger(
                    "6608942705488818925026082852251483154"));
            Qx2 = curve.fromBigInteger(new BigInteger(
                    "110386064370833072982563086539924190163"));
            Qy1 = curve.fromBigInteger(new BigInteger(
                    "233835185036331024500142662901760278727"));
            Qy2 = curve.fromBigInteger(new BigInteger(
                    "269217395288346913820929092968881851980"));
            break;
        case 160:
            Qx1 = curve.fromBigInteger(new BigInteger(
                    "1368080763551537842864000867494632960265168873699"));
            Qx2 = curve.fromBigInteger(new BigInteger(
                    "643284081012003100145372605441605069929358220305"));
            Qy1 = curve.fromBigInteger(new BigInteger(
                    "1429829949789822849115078061391392735933877185539"));
            Qy2 = curve.fromBigInteger(new BigInteger(
                    "320378783996916664601716070577207726212948757265"));
            break;
        case 192:
            Qx1 = curve
                    .fromBigInteger(new BigInteger(
                            "1034344551609471602370610719988082697293410563719698469006"));
            Qx2 = curve
                    .fromBigInteger(new BigInteger(
                            "2903704171802298378325242062709100903880592437723006672773"));
            Qy1 = curve
                    .fromBigInteger(new BigInteger(
                            "1613585477473619097296000057982415887715414154353961900643"));
            Qy2 = curve
                    .fromBigInteger(new BigInteger(
                            "3154781622325109970942793240041155216575064371213525353572"));
            break;
        default:
            Qx1 = null;
            Qx2 = null;
            Qy1 = null;
            Qy2 = null;
            break;
        }

        ECFieldElementFp2 Qx = new ECFieldElementFp2(Qx1, Qx2, true);
        ECFieldElementFp2 Qy = new ECFieldElementFp2(Qy1, Qy2, true);

        return new ECPointFp2(curve.getTwistedCurve(), Qx, Qy);

    }

    /**
     * Construct a number of private attribute keys for the given curve
     */
    static private BigInteger[] constructPrivateAttributeKeys(ECCurve.Fp curve) {
        BigInteger[] private_key;

        private_key = new BigInteger[4];
        switch (curve.getFieldSize()) {
        case 128:
            private_key[0] = new BigInteger(
                    "225372274231985790200027551690655815158");
            private_key[1] = new BigInteger(
                    "245101174517207170638066748358856317475");
            private_key[2] = new BigInteger(
                    "151090931996779535702545347407601272920");
            private_key[3] = new BigInteger(
                    "136791876731881043202558472946915414935");
            break;
        case 160:
            private_key[0] = new BigInteger(
                    "330901983855736385735122296827923334307263610761");
            private_key[1] = new BigInteger(
                    "186811774159849458934010617336619260142261775654");
            private_key[2] = new BigInteger(
                    "200301894953491984814918734560179597654129668224");
            private_key[3] = new BigInteger(
                    "750491186790593356184026972752047947855576453650");
            break;
        case 192:
            private_key[0] = new BigInteger(
                    "3593628016221464844523691788059997682516891660955827077913");
            private_key[1] = new BigInteger(
                    "4464361787165100929465907257058278398048745164767155554885");
            private_key[2] = new BigInteger(
                    "2968611473043184454125366431770946774998904765828172704480");
            private_key[3] = new BigInteger(
                    "2662731123551621877786553098979283273055334939330269203348");
            break;
        default:
            break;
        }

        return private_key;
    }

    static private ECPoint[] constructPublicAttributeKeys(
            BigInteger[] private_key, ECPoint fixed_point) {
        ECPoint[] public_key = new ECPoint[private_key.length];

        for (int i = 0; i < private_key.length; i++) {
            public_key[i] = fixed_point.multiply(private_key[i]);
        }

        return public_key;
    }

    public ECPoint initialiseCard() {

        ECPoint key = null;
        
        byte[][] data = { toAPDU(c.getP()), toAPDU(c.getR()),
                toAPDU(c.getA().toBigInteger()),
                toAPDU(c.getB().toBigInteger()), toAPDU(c.getG()) };
        CommandAPDU cmd = APDUprepare(INITIALISE, data, null);

        try {
            ResponseAPDU response = transmit(cmd);
            if (response.getSW() != 0x9000) {
                if (response.getSW() == 0x6985) {
                    System.err.println("Card already initialised, ignoring.");
                } else {
                    System.err.println("Received SW: " + response.getSW());
                }
            } else {/*
                byte[] resp = response.getData();
                ECCurve curve = new ECCurve.Fp(c.getP(), c.getA()
                        .toBigInteger(), c.getB().toBigInteger());
                int length = ((resp[0] << 8) | (resp[1] & 0xff));
                byte[] pt = new byte[length];
                System.arraycopy(resp, 2, pt, 0, length);
                key = curve.decodePoint(pt);*/
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        return key;

    }

    public ECPoint getCardKey() {

        ECPoint key = null;

        CommandAPDU cmd = APDUprepare(GET_KEY, new byte[][] {}, 256);

        try {
            ResponseAPDU response = transmit(cmd);
            if (response.getSW() != 0x9000) {
                System.err.println("Received SW: " + response.getSW());
            } else {
                byte[] resp = response.getData();
                ECCurve curve = new ECCurve.Fp(c.getP(), c.getA()
                        .toBigInteger(), c.getB().toBigInteger());
                int length = ((resp[0] << 8) | (resp[1] & 0xff));
                byte[] pt = new byte[length];
                System.arraycopy(resp, 2, pt, 0, length);
                key = curve.decodePoint(pt);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        return key;

    }

    public void personalise(byte[] attribute_id) throws CardServiceException {
        ECPoint card_key = getCardKey();

        ECPoint[] cert = constructCertificates(sa, card_key);

        // Select the requested attributes and certificates for personalisation
        byte[][] attribute = new byte[attribute_id.length][];
        ECPoint[] certificate = new ECPoint[attribute_id.length];

        for (int i = 0; i < attribute_id.length; i++) {

            int j = 0;
            while (j < a.length && attribute_id[i] != a[j].id)
                j++;
            attribute[i] = a[j].value;
            certificate[i] = cert[j];
        }

        int length = attribute.length;
        byte[][] data = new byte[length * 3 + 1][];
        data[0] = new byte[2];
        data[0][0] = (byte) ((length & 0xFF00) >> 8);
        data[0][1] = (byte) (length & 0xFF);

        for (int i = 0; i < length; i++) {
            data[3 * i + 1] = new byte[1];
            data[3 * i + 1][0] = attribute_id[i];
            data[3 * i + 2] = certificate[i].getEncoded();
            data[3 * i + 3] = toAPDU(attribute[i]);
        }

        CommandAPDU cmd = APDUprepare(PERSONALISE, data, null);
        transmit(cmd);

    }

    public class AnonymousCertificate {
        public BigInteger signedNonce;
        public BigInteger blindedKey;
        public BigInteger blindedSignature;
        public byte[] attributeValue;
    }

    public void testDH() throws CardServiceException {
    	initialiseCard();
    	
    	BigInteger x = new BigInteger(
                "186811774159849458934010617336619260142261775654");
    	byte[][] data = new byte[2][];
        data[0] = toAPDU(x);
        data[1] = toAPDU(c.getG());
        CommandAPDU cmd = APDUprepare(COMPUTE_DH, data, 256);
        ResponseAPDU response = transmit(cmd);
        if (response.getSW() != 0x9000) {
            System.err.println("Request failed: " + response.getSW());
            return;
        } else {
            byte[] resp = response.getData();
            System.out.println("Response: " + Hex.toHexString(resp));
            ECPoint p = c.getG().multiply(x);
            System.out.println("Expected: " + Hex.toHexString(p.getX().toBigInteger().toByteArray()));
        }
    }
    
    public AnonymousCertificate proveAttribute(int attrIndex)
            throws CardServiceException {
        BigInteger N = BigInteger.probablePrime(127, new SecureRandom());
        ECPoint nonce = c.getG().multiply(N);

        byte[][] data = new byte[2][];
        data[0] = new byte[1];
        data[0][0] = a[attrIndex].id;
        data[1] = toAPDU(nonce);
        CommandAPDU cmd = APDUprepare(GET_ATTRIBUTE, data, null);

        AnonymousCertificate result = new AnonymousCertificate();
        ResponseAPDU response = transmit(cmd);
        if (response.getSW() != 0x9000) {
            System.err.println("Request failed: " + response.getSW());
            return null;
        } else {
            byte[] resp = response.getData();
            int length, offset = 0;
            length = ((resp[offset] << 8) | (resp[offset + 1] & 0xff));
            result.signedNonce = fromAPDU(resp, offset);
            offset += length + 2;
            System.out.println("signedNonce: " + Hex.toHexString(result.signedNonce.toByteArray()));

            length = ((resp[offset] << 8) | (resp[offset + 1] & 0xff));
            result.blindedKey = fromAPDU(resp, offset);
            offset += length + 2;
            System.out.println("blindedKey:  " + Hex.toHexString(result.blindedKey.toByteArray()));
            
            length = ((resp[offset] << 8) | (resp[offset + 1] & 0xff));
            result.blindedSignature = fromAPDU(resp, offset);
            offset += length + 2;
            System.out.println("blindedSig:  " + Hex.toHexString(result.blindedSignature.toByteArray()));
            
            length = ((resp[offset] << 8) | (resp[offset + 1] & 0xff));
            offset += 2;
            result.attributeValue = new byte[length];
            System.arraycopy(resp, offset, result.attributeValue, 0, length);
            System.out.println("attribVal:   " + Hex.toHexString(result.attributeValue));
        }

        System.out.println("signedNonce: " + result.signedNonce);
        System.out.println("blindedKey:  " + result.blindedKey);
        System.out.println("blindedSig:  " + result.blindedSignature);
        System.out.println("attribVal:   " + new String(result.attributeValue));

        // *** NONCE SIGNATURE VERIFICATION ***
        long start = System.nanoTime();
        ECPoint sn = reconstructPoint(c, result.signedNonce, false);
        ECPoint bk = reconstructPoint(c, result.blindedKey, false);

        ECPoint bkn = bk.multiply(N);
        if (!bkn.equals(sn)) {
            if (!bkn.negate().equals(sn)) {
            	System.out.println("Nonce verification failed");
                return null;
            } else {
            }
        } else {
        }
        System.out.println("Nonce verification succeeded");

        // *** PAIRING SIGNATURE VERIFICATION ***
        ECFieldElement e1 = c.R_atePairing(bk, saQ[attrIndex]);

        ECPoint bs = reconstructPoint(c, result.blindedSignature, false);
        ECFieldElement e2 = c.R_atePairing(bs, Q);

        ONE = new ECFieldElementFp12(new ECFieldElement.Fp(c.getQ(), BigInteger
                .valueOf(1)));

        if (!e1.equals(e2)) {
            if (!ONE.equals(e1.multiply(e2))) {
            	System.out.println("Signature verification failed");
                return null;
            } else {
            }
        }
        System.out.println("Signature verification succeeded");
        
        long end = System.nanoTime();
        System.out.format(" d = %.2f ms\n", (end - start) / 1000000.0);
        return result;
    }

    private static ECPoint reconstructPoint(ECCurve c, BigInteger i,
            boolean negate) {
        ECFieldElement x = c.fromBigInteger(i);
        ECFieldElement y = x.multiply(x).multiply(x).add(c.getA().multiply(x))
                .add(c.getB()).sqrt();
        if (negate) {
            return c.createPoint(x.toBigInteger(), y.toBigInteger().negate(),
                    false);
        } else {
            return c.createPoint(x.toBigInteger(), y.toBigInteger(), false);
        }
    }

    static private ECPoint[] constructCertificates(BigInteger[] private_key,
            ECPoint public_key) {
        ECPoint[] certificate = new ECPoint[private_key.length];

        for (int i = 0; i < private_key.length; i++) {
            certificate[i] = public_key.multiply(private_key[i]);
        }

        return certificate;
    }

    public void addAPDUListener(APDUListener l) {
        service.addAPDUListener(l);
    }

    public void removeAPDUListener(APDUListener l) {
        service.removeAPDUListener(l);
    }

    public void close() {
        if (service != null) {
            service.close();
        }
    }

    public boolean isOpen() {
        return service.isOpen();
    }

    public void open() throws CardServiceException {
        if (!service.isOpen()) {
            service.open();
        }
        sendSelectApplet();
    }

    public void sendSelectApplet() throws CardServiceException {
        CommandAPDU c = new CommandAPDU(0, 0xA4, (byte) 0x04, (byte) 0x00, AID, 256);
        ResponseAPDU r = transmit(c);
        if (r.getSW() != 0x00009000) {
            throw new CardServiceException("Could not select the AC applet.");
        }

    }

    /**
     * Send an APDU over the communication channel to the smart card.
     *
     * @param apdu the APDU to be send to the smart card.
     * @return ResponseAPDU the response from the smart card.
     * @throws CardServiceException if some error occurred while transmitting.
     */
    public ResponseAPDU transmit(CommandAPDU capdu)
    throws CardServiceException {

        if (VERBOSE) {
            System.out.println();
            System.out.println("C: " + Hex.bytesToHexString(capdu.getBytes()));
        }

        long start = System.nanoTime();
        ResponseAPDU rapdu = service.transmit(capdu);
        long duration = (System.nanoTime() - start)/1000000;

        if (VERBOSE) {
            System.out.println(" duration: " + duration + " ms");
            System.out.println("R: " + Hex.bytesToHexString(rapdu.getBytes()));
        }

        return rapdu;
    }

    private byte[] toAPDU(ECPoint p) {
        byte[] array = p.getEncoded();

        byte[] result = new byte[2 + array.length];
        result[0] = (byte) (array.length >> 8);
        result[1] = (byte) array.length;
        System.arraycopy(array, 0, result, 2, array.length);

        return result;
    }

    private byte[] toAPDU(BigInteger i) {
        byte[] array = i.toByteArray();

        int length = (i.bitLength() + 7) / 8;
        if (length == 0)
            length++;
        int offset = array.length - length;

        byte[] result = new byte[length + 2];
        result[0] = (byte) ((length & 0xff00) >> 8);
        result[1] = (byte) (length & 0xff);
        System.arraycopy(array, offset, result, 2, length);
        System.out.println("[toAPDU] length: " + length + " value: " + Hex.toHexString(array) + " result: " + Hex.toHexString(result));

        return result;
    }

    private byte[] toAPDU(byte[] value) {
        int length = value.length;
        byte[] result = new byte[length + 2];
        result[0] = (byte) ((length & 0xff00) >> 8);
        result[1] = (byte) (length & 0xff);
        System.arraycopy(value, 0, result, 2, length);
        System.out.println("[toAPDU] length: " + length + " value: " + Hex.toHexString(value) + " result: " + Hex.toHexString(result));

        return result;
    }

    private BigInteger fromAPDU(byte[] array, int offset) {
        int length = ((array[offset] << 8) | (array[offset + 1] & 0xff));
        System.out.println("[fromAPDU] length: " + length + " offset: " + offset + " value: " + Hex.toHexString(array));
        array[offset + 1] = 0x00;
        return new BigInteger(Arrays.copyOfRange(array, offset + 1, offset + 2
                + length));
    }

    private CommandAPDU APDUprepare(int[] c, byte[][] d, Integer le) {
        int length = 0;
        for (int i = 0; i < d.length; i++) {
            length += d[i].length;
        }

        byte[] data = new byte[length];
        int offset = 0;
        for (int i = 0; i < d.length; i++) {
            System.arraycopy(d[i], 0, data, offset, d[i].length);
            offset += d[i].length;
        }

        if (le == null) {
        	return new CommandAPDU(c[0], c[1], c[2], c[3], data);
        } else {
        	return new CommandAPDU(c[0], c[1], c[2], c[3], data, le);
        }
    }

	@Override
	public byte[] transmitControlCommand(int controlCode, byte[] command)
			throws CardServiceException {
		return service.transmitControlCommand(controlCode, command);
	}

	@Override
	public byte[] getATR() throws CardServiceException {
		return service.getATR();
	}

	@Override
	public String getName() {
		return "ACService: " + service.getName();
	}

}
